{"meta":{"title":"ZCY的博客","subtitle":null,"description":null,"author":"Chenyu Zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-30","excerpt":""},{"title":"about","text":"一只小菜鸡","path":"about/index.html","date":"07-30","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-30","excerpt":""}],"posts":[{"title":"莫比乌斯反演入门","text":"终于开写自己的第一篇博客了qaq总结一下简单的莫比乌斯吧立个flag明天搞杜教筛 \\sum_{i=1}^n a_i=0$\\sum_{i=1}^n a$莫比乌斯反演入门讲解 莫比乌斯反演的两种形式： 若 $F(n)=\\sum_{d|n}f(n)$ 则 $f(n)=\\sum_{d|n}\\mu(d)F(\\frac{n}{d})$ 若 $F(n)=\\sum_{n|d}f(n)$ 则 $f(n)=\\sum_{n|d}\\mu(\\frac{d}{n})F(d)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define int __int128int gcd(int x, int y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;int egcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int p = egcd(b, a % b, y, x); y -= a / b * x; return p;&#125;int k, n, m[15], b[15],b1, b2, m1, m2, d, p, x, y, b3, m3;bool uni(int i)&#123; d = gcd(m1, m2); if ((b1 - b2) % d) return false; egcd(m1 / d, m2 / d, x, y); b3 = b1 + m1 * (b2 - b1) / d * x, m3 = m1 * m2 / d; b[i] = (b3 % m3 + m3) % m3, m[i] = m3; return true;&#125;signed main()&#123; long long temp; cin &gt;&gt; temp; int k = temp; for (int i = 1; i &lt;= k; i ++) &#123; cin &gt;&gt; temp, m[i] = temp; cin &gt;&gt; temp, b[i] = temp; b[i] = (b[i] % m[i] + m[i]) % m[i]; &#125; // for (int i = 1; i &lt;= k; i ++) cout &lt;&lt; (long long)b[i] &lt;&lt; endl; for (int i = 2; i &lt;= k; i ++) &#123; b1 = b[i - 1], b2 = b[i], m1 = m[i - 1], m2 = m[i]; if (!uni(i)) &#123; cout &lt;&lt; \"Tankernb!\" &lt;&lt; endl; return 0; &#125; long long tt = b[i], mm = m[i]; // cout &lt;&lt; tt &lt;&lt; \" \" &lt;&lt; mm &lt;&lt; endl; &#125; n = (b[k] % m[k] + m[k]) % m[k]; // long long tt = n, mm = m[k]; // cout &lt;&lt; tt &lt;&lt; \" \" &lt;&lt; mm &lt;&lt; endl; // cin &gt;&gt; temp; n = temp; if (n &lt;= 3) &#123; cout &lt;&lt; \"Lbnb!\" &lt;&lt; endl; return 0; &#125; int f1 = 1, f2 = 1, f3; while (f2 &lt; n) &#123; f3 = f1 + f2; f1 = f2, f2 = f3; &#125; if (f3 == n) cout &lt;&lt; \"Lbnb!\" &lt;&lt; endl; else cout &lt;&lt; \"Zgxnb!\" &lt;&lt; endl;&#125;","path":"2019/09/07/tt/","date":"09-07","excerpt":"终于开写自己的第一篇博客了qaq总结一下简单的莫比乌斯吧立个flag明天搞杜教筛","tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://yoursite.com/tags/莫比乌斯反演/"}]},{"title":"四种简单博弈","text":"&emsp;&emsp;今天遇到了斐波那契博弈自己瞎搞了半天还是推错了规律，没想到是个经典问题，来学习一下。 这四个取物博弈均为：两人取一堆物品，取走最后一个者胜，两人轮流取。 1. 巴什博弈规则：每次取物品数量在 1 到 m若物品有 m + 1 个则第一个人无论怎样取，第二个人都可以取完故若 n % (m + 1) == 0 每一轮第二个人都能使物品商量为 m + 1 的倍数，从而最终获胜；反之，第一个人取一次使得物品数量为 m + 1 的倍数，最终获胜。 2. 威佐夫博弈规则：每次从一堆或两堆中取相同数量的物品，最少一个，多者不限解法：明天更 3. 尼姆博弈明天更 4. 斐波那契博弈规则：第一次至少取一个且不能取完，以后每次至少一个，至多是上一次对方取物的两倍物品数量为斐波那契数时，该人必败，否则必胜。 困了，明天早起打银川辣鸡网络重赛","path":"2019/09/07/四种简单博弈/","date":"09-07","excerpt":"","tags":[{"name":"博弈论","slug":"博弈论","permalink":"http://yoursite.com/tags/博弈论/"}]},{"title":"前言","text":"&emsp;&emsp;好多东西学了过一段时间就忘掉很多，写写博客记录一下学习的知识和有趣的生活吧。&emsp;&emsp;作为一个菜鸡ACMer再不努力一下怕是没打过比赛就退役了qwq。","path":"2019/09/07/前言/","date":"09-07","excerpt":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]}]}